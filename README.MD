

# Итоговая контрольная работа по основному блоку

Данная работа необходима для проверки ваших знаний и навыков по итогу прохождения первого блока обучения на программе Разработчик. Мы должны убедится, что базовое знакомство с IT прошло успешно.

## Задание
Задача алгоритмически не самая сложная, однако для полноценного выполнения проверочной работы необходимо:

1. Создать репозиторий на GitHub
2. Нарисовать блок-схему алгоритма (можно обойтись блок-схемой основной содержательной части, если вы выделяете её в отдельный метод)
3. Снабдить репозиторий оформленным текстовым описанием решения (файл README.md)
4. Написать программу, решающую поставленную задачу
5. Использовать контроль версий в работе над этим небольшим проектом (не должно быть так, что всё залито одним коммитом, как минимум этапы 2, 3, и 4 должны быть расположены в разных коммитах)

Задача: Написать программу, которая из имеющегося массива строк формирует новый массив из строк, длина которых меньше, либо равна 3 символам. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

Примеры:
[“Hello”, “2”, “world”, “:-)”] → [“2”, “:-)”]
[“1234”, “1567”, “-2”, “computer science”] → [“-2”]
[“Russia”, “Denmark”, “Kazan”] → []

## Описание решения

1. Функция вывода строкового массива с пропуском пустых элементов **PrintStringArr** (сначала вычисляет последний непустой элемент, потому что после него запятая не ставится, затем выводит элементы массива через запятую, вывод массива обрамляется квадратными скобками).
2. Функция **CutStringsInArray** формирует новый **newArr** строковый массив из элементов поданного на вход строкового массива (параметр **string[] arr**), где длина элементов меньше, либо равна параметру **maxLength**, а длина нового массива **newArr** равна длине исходного массива **newArr**.
3. В функции **CutStringsInArray** есть проверка, что максимальная длина строки больше 0: при вводе maxLength < 0 функция будет вести себя как, если бы maxLength = 0.
4. Переменная **int stringLength = 0** используется для хранения длины строки для записи в новый массив, изначально ей присвоено значение 0.
5. В функции используется конструктор класса Random **Random rnd = new Random();**.
6. В функции есть цикл **с счетчиком i**, который
    - Для каждого элемента arr определит количество символов для записи в новый массив с помощью конструктора Random и ограничения длины строки либо изначальной строкой, либо максимальной длиной принятой функцией в качестве аргумента
        - Если **arr[i].Length == 0**, то присвоит переменной **stringLength** значение **0**
        - ИначеЕсли **arr[i].Length >= length**, то  присвоит переменной **stringLength** случайное значение от **0** до **length** включительно
        - Иначе случайно присвоит переменной **stringLength** случайное значение от **0** до **arr[i].Length** включительно
    - Если **stringLength == 0**, то оставит элемент нового массива пустым.
7. Внутри цикла **с счетчиком i** есть вложенный цикл **с счетчиком j**, который
    - Записывает по одному символу из соответствующего элемента заданного массива в элемент нового массива, пока не запишет нужное количество символов **== stringLength**.
8.  В рамках решения задается массив из строк, длинной 5, со значениями: "Elephant", "Koala", "", "E", "Jaguar".
9.  С помощью функции **CutStringsInArray** создается массив **newArray**, в качестве аргументов в фукцию передаются заданный массив **array** для параметра **arr** , и **3** для параметра **maxLength**.
10. Далее выводятся помощью функции **PrintStringArr** заданный массив, и полученный новый массив в терминал, такж между массивами выводится "стрелка" " -> "
    - Примечание: если строка пустая, то она выводится не будет
    - Пример: ["Ele", "K", "", "E", ""] -> [Ele, K, E].
11. В итоге программа, выполняет поставленную задачу: из имеющегося массива строк формирует новый массив из строк, длина которых меньше, либо равна 3 символам.